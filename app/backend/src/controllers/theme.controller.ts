import { Response } from 'express';
import { z } from 'zod';
import { AuthRequest } from '../types';
import { ThemeService } from '../services/theme.service';
import { logger } from '../utils/logger';

// ============================================
// VALIDATION SCHEMAS
// ============================================

const themeColorsSchema = z.object({
  primary: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  secondary: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  accent: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  background: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  surface: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  text: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  textSecondary: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  border: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  error: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  warning: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  success: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
  info: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Must be a valid hex color'),
});

const themeFontsSchema = z.object({
  body: z.string().min(1, 'Body font is required'),
  heading: z.string().min(1, 'Heading font is required'),
  mono: z.string().min(1, 'Monospace font is required'),
});

const createThemeSchema = z.object({
  name: z.string().min(1).max(255),
  colors: themeColorsSchema,
  fonts: themeFontsSchema,
  isDark: z.boolean().default(false),
  isDefault: z.boolean().default(false),
});

const updateThemeSchema = z.object({
  name: z.string().min(1).max(255).optional(),
  colors: themeColorsSchema.optional(),
  fonts: themeFontsSchema.optional(),
  isDark: z.boolean().optional(),
  isDefault: z.boolean().optional(),
});

const validateThemeSchema = z.object({
  name: z.string().min(1).max(255),
  colors: themeColorsSchema,
  fonts: themeFontsSchema,
  isDark: z.boolean().default(false),
});

// ============================================
// CONTROLLER METHODS
// ============================================

/**
 * Create a new custom theme
 * POST /api/v1/themes
 */
export const createTheme = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const data = createThemeSchema.parse(req.body);

    const theme = await ThemeService.createTheme(userId, {
      name: data.name,
      colors: data.colors,
      fonts: data.fonts,
      isDark: data.isDark,
      isDefault: data.isDefault,
      cssVariables: {}, // Will be generated by service
    });

    res.status(201).json({
      theme,
      message: 'Theme created successfully',
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.errors,
      });
    }

    logger.error('Create theme error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Failed to create theme',
    });
  }
};

/**
 * Get all themes for the authenticated user
 * GET /api/v1/themes
 */
export const getUserThemes = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const themes = await ThemeService.getUserThemes(userId);

    res.json({
      themes,
      total: themes.length,
    });
  } catch (error) {
    logger.error('Get user themes error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to fetch themes',
    });
  }
};

/**
 * Get a specific theme by ID
 * GET /api/v1/themes/:id
 */
export const getThemeById = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    const theme = await ThemeService.getTheme(userId, id);

    if (!theme) {
      return res.status(404).json({
        error: 'Not Found',
        message: 'Theme not found',
      });
    }

    res.json({ theme });
  } catch (error) {
    logger.error('Get theme error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to fetch theme',
    });
  }
};

/**
 * Update a theme
 * PUT /api/v1/themes/:id
 */
export const updateTheme = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;
    const updates = updateThemeSchema.parse(req.body);

    const theme = await ThemeService.updateTheme(userId, id, updates);

    res.json({
      theme,
      message: 'Theme updated successfully',
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.errors,
      });
    }

    logger.error('Update theme error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Failed to update theme',
    });
  }
};

/**
 * Delete a theme
 * DELETE /api/v1/themes/:id
 */
export const deleteTheme = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    await ThemeService.deleteTheme(userId, id);

    res.json({
      message: 'Theme deleted successfully',
    });
  } catch (error) {
    logger.error('Delete theme error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Failed to delete theme',
    });
  }
};

/**
 * Export theme as CSS
 * GET /api/v1/themes/:id/css
 */
export const exportThemeCSS = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    const css = await ThemeService.exportThemeCSS(userId, id);

    res.setHeader('Content-Type', 'text/css');
    res.setHeader('Content-Disposition', `attachment; filename="theme-${id}.css"`);
    res.send(css);
  } catch (error) {
    logger.error('Export theme CSS error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Failed to export theme',
    });
  }
};

/**
 * Export theme as Tailwind config
 * GET /api/v1/themes/:id/tailwind
 */
export const exportThemeTailwind = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    const { id } = req.params;

    const config = await ThemeService.exportThemeTailwind(userId, id);

    res.setHeader('Content-Type', 'application/javascript');
    res.setHeader('Content-Disposition', `attachment; filename="tailwind.config.js"`);
    res.send(config);
  } catch (error) {
    logger.error(
      'Export theme Tailwind error:',
      error instanceof Error ? error : new Error(String(error))
    );
    res.status(500).json({
      error: 'Internal Server Error',
      message: error instanceof Error ? error.message : 'Failed to export theme',
    });
  }
};

/**
 * Get theme presets
 * GET /api/v1/themes/presets
 */
export const getPresets = async (req: AuthRequest, res: Response) => {
  try {
    const presets = ThemeService.getPresets();

    res.json({
      presets,
      total: presets.length,
    });
  } catch (error) {
    logger.error('Get presets error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to fetch presets',
    });
  }
};

/**
 * Get theme templates
 * GET /api/v1/themes/templates
 */
export const getTemplates = async (req: AuthRequest, res: Response) => {
  try {
    const { category } = req.query;
    const templates = await ThemeService.getTemplates(category as string | undefined);

    res.json({
      templates,
      total: templates.length,
    });
  } catch (error) {
    logger.error('Get templates error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to fetch templates',
    });
  }
};

/**
 * Get font pairing suggestions
 * GET /api/v1/themes/font-pairings
 */
export const getFontPairings = async (req: AuthRequest, res: Response) => {
  try {
    const { category } = req.query;
    const pairings = ThemeService.getFontPairings(category as string | undefined);

    res.json({
      pairings,
      total: pairings.length,
    });
  } catch (error) {
    logger.error(
      'Get font pairings error:',
      error instanceof Error ? error : new Error(String(error))
    );
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to fetch font pairings',
    });
  }
};

/**
 * Validate theme data
 * POST /api/v1/themes/validate
 */
export const validateTheme = async (req: AuthRequest, res: Response) => {
  try {
    const data = validateThemeSchema.parse(req.body);
    const validation = ThemeService.validateThemeData(data);

    res.json({
      validation,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({
        error: 'Validation Error',
        message: error.errors,
      });
    }

    logger.error('Validate theme error:', error instanceof Error ? error : new Error(String(error)));
    res.status(500).json({
      error: 'Internal Server Error',
      message: 'Failed to validate theme',
    });
  }
};
