// Prisma Schema for EarnTrack
// Database: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String     @id @default(uuid())
  email        String     @unique
  passwordHash String     @map("password_hash")
  name         String?
  timezone     String     @default("UTC")
  currency     String     @default("USD") @db.VarChar(3)

  // Email notification preferences
  emailNotificationsEnabled Boolean @default(true) @map("email_notifications_enabled")
  weeklyReportEnabled Boolean @default(true) @map("weekly_report_enabled")
  invoiceNotificationEnabled Boolean @default(true) @map("invoice_notification_enabled")
  expenseAlertEnabled Boolean @default(true) @map("expense_alert_enabled")

  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  platforms      Platform[]
  earnings       Earning[]
  goals          Goal[]
  products       Product[]
  sales          Sale[]
  inventoryLogs  InventoryLog[]
  customers      Customer[]
  expenses       Expense[]
  invoices       Invoice[]
  documents      Document[]

  // Index for email-based lookups (for authentication)
  @@index([email])
  @@map("users")
}

model Platform {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  name         String    @db.VarChar(100)
  category     String    @db.VarChar(50) // freelance, delivery, services, other
  color        String?   @db.VarChar(7) // hex color
  expectedRate Decimal?  @map("expected_rate") @db.Decimal(10, 2)
  isActive     Boolean   @default(true) @map("is_active")
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  earnings     Earning[]

  @@unique([userId, name])
  @@index([userId, isActive])
  @@map("platforms")
}

model Earning {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  platformId String   @map("platform_id")
  date       DateTime @db.Date
  hours      Decimal? @db.Decimal(5, 2)
  amount     Decimal  @db.Decimal(10, 2)
  notes      String?  @db.Text
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform   Platform @relation(fields: [platformId], references: [id], onDelete: Cascade)

  // Index for user earnings by date (most common query)
  @@index([userId, date(sort: Desc)])
  // Index for platform earnings history
  @@index([platformId, date(sort: Desc)])
  // Composite index for filtered earnings queries (userId + date range)
  @@index([userId, platformId, date(sort: Desc)])
  @@map("earnings")
}

model Goal {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  type         String   @db.VarChar(50) // daily, weekly, monthly
  targetAmount Decimal  @map("target_amount") @db.Decimal(10, 2)
  startDate    DateTime @map("start_date") @db.Date
  endDate      DateTime? @map("end_date") @db.Date
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Index for user-scoped goal queries
  @@index([userId, isActive])
  @@map("goals")
}

model Product {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  name         String   @db.VarChar(255)
  description  String?  @db.Text
  price        Decimal  @db.Decimal(10, 2)
  category     String?  @db.VarChar(100)
  sku          String?  @db.VarChar(100) // Stock Keeping Unit

  // Inventory tracking
  quantity     Decimal  @default(0) @db.Decimal(10, 2)
  reorderPoint Decimal  @default(10) @map("reorder_point") @db.Decimal(10, 2)
  supplierName String?  @map("supplier_name") @db.VarChar(255)
  supplierCost Decimal? @map("supplier_cost") @db.Decimal(10, 2)

  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  sales        Sale[]
  inventoryLogs InventoryLog[]

  @@unique([userId, name])
  @@index([userId, isActive])
  @@map("products")
}

model Sale {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  productId    String   @map("product_id")
  quantity     Decimal  @db.Decimal(10, 2)
  unitPrice    Decimal  @map("unit_price") @db.Decimal(10, 2)
  totalAmount  Decimal  @map("total_amount") @db.Decimal(12, 2)
  saleDate     DateTime @map("sale_date") @db.Date
  customer     String?  @db.VarChar(255)
  notes        String?  @db.Text
  status       String   @default("completed") @db.VarChar(50) // completed, pending, cancelled
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  product      Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Index for user-scoped sales by date
  @@index([userId, saleDate(sort: Desc)])
  // Index for product sales history
  @@index([productId, saleDate(sort: Desc)])
  // Index for sale status filtering
  @@index([userId, status])
  @@map("sales")
}

model InventoryLog {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  productId    String   @map("product_id")
  quantityChange Decimal @map("quantity_change") @db.Decimal(10, 2)
  type         String   @db.VarChar(50) // purchase, sale, adjustment, damage, return
  notes        String?  @db.Text
  createdAt    DateTime @default(now()) @map("created_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  product      Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([productId, createdAt(sort: Desc)])
  @@map("inventory_logs")
}

model Customer {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  name         String   @db.VarChar(255)
  email        String?  @db.VarChar(255)
  phone        String?  @db.VarChar(20)
  company      String?  @db.VarChar(255)
  address      String?  @db.Text
  city         String?  @db.VarChar(100)
  country      String?  @db.VarChar(100)

  // Customer metrics
  totalPurchases Decimal @default(0) @map("total_purchases") @db.Decimal(12, 2)
  totalQuantity  Decimal @default(0) @map("total_quantity") @db.Decimal(10, 2)
  purchaseCount  Int     @default(0) @map("purchase_count")
  lastPurchase   DateTime? @map("last_purchase")

  notes        String?  @db.Text
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  invoices     Invoice[]

  @@unique([userId, email])
  // Index for basic user-scoped queries
  @@index([userId, isActive])
  // Indexes for common sorting patterns (LTV, recency, frequency)
  @@index([userId, totalPurchases(sort: Desc)])
  @@index([userId, lastPurchase(sort: Desc)])
  @@index([userId, purchaseCount(sort: Desc)])
  // Index for customer name search (full-text would be better in production)
  @@index([userId, name])
  @@map("customers")
}

model Expense {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  category     String   @db.VarChar(100)
  description  String   @db.Text
  amount       Decimal  @db.Decimal(10, 2)
  expenseDate  DateTime @map("expense_date") @db.Date

  // Expense details
  vendor       String?  @db.VarChar(255)
  isTaxDeductible Boolean @default(false) @map("is_tax_deductible")
  receiptUrl   String?  @map("receipt_url") @db.Text

  notes        String?  @db.Text
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expenseDate(sort: Desc)])
  @@index([userId, category])
  @@map("expenses")
}

model Invoice {
  id           String   @id @default(uuid())
  userId       String   @map("user_id")
  customerId   String?  @map("customer_id")
  invoiceNumber String  @map("invoice_number") @db.VarChar(100)

  // Invoice details
  subtotal     Decimal  @db.Decimal(12, 2)
  taxAmount    Decimal  @default(0) @map("tax_amount") @db.Decimal(10, 2)
  discountAmount Decimal @default(0) @map("discount_amount") @db.Decimal(10, 2)
  totalAmount  Decimal  @map("total_amount") @db.Decimal(12, 2)

  // Dates
  invoiceDate  DateTime @map("invoice_date") @db.Date
  dueDate      DateTime @map("due_date") @db.Date
  paidDate     DateTime? @map("paid_date") @db.Date

  // Status
  status       String   @default("draft") @db.VarChar(50) // draft, sent, viewed, paid, overdue, cancelled
  paymentMethod String? @map("payment_method") @db.VarChar(50) // cash, card, bank, other

  notes        String?  @db.Text
  terms        String?  @db.Text

  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  customer     Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  lineItems    InvoiceLineItem[]

  @@unique([userId, invoiceNumber])
  // Index for invoice list by date
  @@index([userId, invoiceDate(sort: Desc)])
  // Index for filtering by status
  @@index([userId, status])
  // Index for overdue invoice detection (dueDate + status filter)
  @@index([userId, dueDate(sort: Asc), status])
  // Index for customer-scoped invoice queries
  @@index([customerId, userId])
  @@map("invoices")
}

model InvoiceLineItem {
  id           String   @id @default(uuid())
  invoiceId    String   @map("invoice_id")
  description  String   @db.Text
  quantity     Decimal  @db.Decimal(10, 2)
  unitPrice    Decimal  @map("unit_price") @db.Decimal(10, 2)
  totalPrice   Decimal  @map("total_price") @db.Decimal(12, 2)

  invoice      Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@map("invoice_line_items")
}

model Document {
  id           String   @id // Custom ID (file hash)
  userId       String   @map("user_id")
  filename     String   @db.VarChar(255)
  storageName  String   @map("storage_name") @db.VarChar(255) // Name in storage
  mimetype     String   @db.VarChar(50)
  size         Int      // File size in bytes
  uploadedAt   DateTime @map("uploaded_at") @default(now())

  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, id])
  @@index([userId, uploadedAt(sort: Desc)])
  @@map("documents")
}

model Job {
  id           String   @id @default(uuid())
  jobName      String   @map("job_name") @db.VarChar(255)
  status       String   @default("idle") @db.VarChar(50) // idle, running, success, error
  lastRun      DateTime? @map("last_run")
  nextRun      DateTime? @map("next_run")
  error        String?  @db.Text
  isEnabled    Boolean  @default(true) @map("is_enabled")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  logs         JobLog[]

  @@unique([jobName])
  @@index([status])
  @@index([nextRun])
  @@map("jobs")
}

model JobLog {
  id           String   @id @default(uuid())
  jobId        String   @map("job_id")
  status       String   @db.VarChar(50) // success, error, skipped
  duration      Int      @db.Integer // Duration in milliseconds
  error        String?  @db.Text
  metadata     String?  @db.Text // JSON string for additional data
  createdAt    DateTime @default(now()) @map("created_at")

  job          Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, createdAt(sort: Desc)])
  @@map("job_logs")
}
